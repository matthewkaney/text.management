<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <style type="text/css">
      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
      }

      canvas {
        display: block;
      }
    </style>
    <script type="module">
      import * as THREE from "three";

      window.THREE = THREE;

			const renderer = new THREE.WebGLRenderer({ alpha: true });
			renderer.setSize( window.innerWidth, window.innerHeight );

      window.scene = new THREE.Scene();

      window.camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 1000 );
      camera.position.y = 4;
      camera.position.z = 5;
      camera.rotation.x = -0.3;

      window.makeLight = (name, color = "white", x = 0, y = 0, z = 0) => {
        if (scene.children.includes(window[name])) {
          scene.remove(window[name]);
        }
        
        window[name] = new THREE.PointLight(new THREE.Color(color));
        window[name].position.set(x, y, z);
        scene.add(window[name]);
      };

      window.lights = (top = "pink", bottom = "lightblue") => {
        if (scene.children.includes(window.hemi)) {
          scene.remove(window.hemi);
        }

        if (!top) {
          return;
        }
        
        window.hemi = new THREE.HemisphereLight(new THREE.Color(top), new THREE.Color(bottom));
        scene.add(window.hemi);
      };

      window.makeSphere = (name, color = "white", scale = 1, x = 0, y = 0, z = 0) => {
        if (scene.children.includes(window[name])) {
          scene.remove(window[name]);
        }

        window[name] = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 16), new THREE.MeshStandardMaterial({ color: new THREE.Color(color) }));
        window[name].position.set(x, y, z);
        window[name].scale.set(scale, scale, scale);
        scene.add(window[name]);
      };

      import Hydra from "hydra-synth";

      const hydra = new Hydra({ autoLoop: false });
      s0.init({ src: renderer.domElement });

      let lastTime = performance.now();

      let updater = () => {};

      window.move = (updateFunc) => {
        updater = updateFunc;
      };

      function animate(thisTime) {
				requestAnimationFrame( animate );

        let dt = thisTime - lastTime;
        lastTime = thisTime;

        try {
				  updater(thisTime);
        } catch (e) {
          console.log(e);
        }

				renderer.render( scene, camera );

        hydra.tick(dt);
			};

			animate(lastTime);

      import { getMessages } from "../../../app/osc/osc";

      window.addEventListener("message", ({ data, ports }) => {
        if (data === "channel" && ports.length > 0) {
          let [port] = ports;

          port.addEventListener("message", ({ data }) => {
            for (let {
              address,
              args: [code],
            } of getMessages(data)) {
              if (address === "/code" && typeof code === "string") {
                try {
                  eval(code);
                } catch (error) {
                  console.log(error.message);
                }
              }
            }
          });

          port.addEventListener("messageerror", (event) => {
            console.error(event);
          });

          port.start();
        }
      });
    </script>
  </head>
</html>
